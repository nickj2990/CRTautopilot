
#include <PWMServo.h>
#include <Adafruit_GPS.h>
#include <Adafruit_PMTK.h>
#include <NMEA_data.h>
#include <SparkFunMPL3115A2.h>
#include <SBUS.h>
#include <Watchdog.h>
#include <movingAvg.h>
#include <EEPROM.h>


// Setup
 
#define time_out 300
//Settings 
#define gps_frequency   5  
#define vzmax          1.5
#define vz_max          2
#define z_safety        100

#define servo_auto_min 1100 
#define servo_auto_max 1900
#define servoLMin 2000 
#define servoLMid 1300
#define servoLMax 1000
#define servoRMin 200
#define servoRMid 1300
#define servoRMax 1000
//Testing 
#define initialize 

#define gliding_timer 2500
int dep_altitude = z_safety; 
int cog_count = 2;  
// NAV PIDs // 
float NKp = 0.8; 
float NKd = 0.15; 


// Altitude
MPL3115A2 myPressure;
float alt = 0;
float prev_alt = 0; 
float vspeed = 0; 
float baro_set = 1000; 
float baro_count = 0; 
int vspeed_count = 0;
boolean new_baro = false;
float dt = 0; 
movingAvg al(5); 
movingAvg vs(5); 

//GPS
TinyGPSCustom fix_type(gps, "GNGSA", 2);
movingAvg rs(2); 
unsigned char serial2bufferRead[1000];
float prev_cog = 0;
int gps_count = 0; 
int valid_count = 0; 
float prev_gps = 0; 
boolean new_gps = false; 
boolean cog_ok = 0; 
boolean new_cog = false; 


int sw = 22; 
int crash_count = 0; 
int cells = 0; 
boolean armed = false;    
movingAvg rc(2); 
movingAvg mult(10); 
float merged_alt = 0; 
float setPoint_Home = 0; 
float errHome = 0;
float raterror = 0; 
float last_errHome = 0; 
float baro_weight = 1;
float gps_weight = 1; 
float lat_B = 0; 
float lon_B = 0; 
float cmd = 0; 
boolean spiral = false; 
float cmdHome = 1500; 
float next_cog = 0; 
float ratecog = 0; 
float prev_cog_b = 0;
float cmd_mult = 0;  


// SERVO /  
movingAvg st(5); 
PWMServo steer;
PWMServo deploy; 
PWMServo left; 
PWMServo right; 


float roll_man = 1500; 
float pitch_man = 1500; 
float steer_auto = 1500; 
float servo_deploy = 2000;
float servoL = 1500; 
float servoR = 1500; 

int flight_mode = 0; 
int prev_mode = 0; 
bool deployed = false; 
bool baro_stab = false; 
bool gps_stab = false; 
bool initialised = false;
bool wing_opened = false;  

bool gps_ok = false; 

int packet_count = 0; 
int reboot_state = 0; 
char sdnamebuff[20]; 
char mainSD[240];

int time_number = 0; 
boolean flight_rebooted = false; 

unsigned long baroA = 0; 
unsigned long baroB = 0; 
unsigned long tstab = 0; 
unsigned long sd = 0; 
unsigned long baro_blk = 0; 
unsigned long time_init = 0; 
unsigned long sat_buzz = 0; 
unsigned long tparallax = 0; 
unsigned long tpwm = 0; 
unsigned long batt_buzz = 0; 
unsigned long long tloop = 0; 
unsigned long long tgps = 0; 
unsigned long long tup = 0; 
unsigned long long tdown = 0; 
unsigned long t_turn = 0; 

unsigned long long reboot_time = 0; 
int loop_time = 999; 

int delaySD = 100;


  char lat_A_text[30];
  char lon_A_text[30];
  char alt_gps_text[30];
  char cog_text[30]; 
  char speed_text[30];
  char sat_text[30];
  char fix_type_text[10];
  char hdop_text[10];
  char pos_age_text[10]; 
  char count_text[10]; 
  char time_text[10];

  char Z_text[30];
  char vspeed_text[30];

  char merged_alt_text[30];
  char baro_weight_text[30];
  char gps_weight_text[30]; 
  char setPoint_Home_text[30]; 
  char lat_B_text[30];
  char lon_B_text[30];
  char errHome_text[30]; 
  char raterror_text[30]; 

  
  char deploy_text[10]; 
  char left_text[10]; 
  char right_text[10]; 
  
  char gps_ok_text[10];
  char cog_ok_text[10];    
  char failSafe_text[10]; 
  char baro_stab_text[10]; 
  char gps_stab_text[10]; 
  char deployed_text[10]; 
  char flight_mode_text[10]; 
  char vbatt_text[10]; 
  char looptime_text[10]; 
  char packet_count_text[10]; 
  char initialised_text[10]; 
  char wing_opened_text[10]; 
  char next_cog_text[10]; 
  char cmd_mult_text[10]; 
  
  char mintext[120];
  char gps_text[120]; 
  char baro_text[120];
  char servo_text[120]; 
  char status_text[120]; 
  char alt_text[120]; 
  char nav_text[120]; 

  char _time[80];
  char _year[10]; 
  char _month[10]; 
  char _day[10]; 
  char _hour[10]; 
  char _minute[10];
  char _seconds[10];

Watchdog watchdog;


void setup() {
  
  pinMode(A17, INPUT); 
  pinMode(sw, INPUT); 
  
  Serial5.begin(57600); 

  vs.begin(); 
  al.begin(); 
  roll_steer.begin();
  pitch_steer.begin();
  rs.begin(); 
  rc.begin();
  mult.begin();  

  left.attach(6, 1000, 2000);  
  right.attach(7, 1000, 2000); 
  deploy.attach(8, 1000, 2000)

  
  bmp.begin(0X11);

// For restarting 
  EEPROM.get(0, reboot_state);

  if (reboot_state == 1) { 
    EEPROM.get(10, dep_altitude);
    EEPROM.get(30, lat_B);
    EEPROM.get(50, lon_B);
    EEPROM.get(70, baro_set);
    EEPROM.get(90, time_number);
    EEPROM.get(120, reboot_time);

    flight_rebooted = true; 
  }

 watchdog.enable(Watchdog::TIMEOUT_1S);
 
}

void loop() {
  
  tloop = micros(); 
  
  getdata();
  datacmpt(); 

  flight_state(); 

  applycmd();
  updatecmd(50);


  loop_time = (micros()-tloop); 
  if (loop_time<150000) {watchdog.reset(); crash_count = 0; }
  if (loop_time>150000) { 
    crash_count = (crash_count + 1); 
    if (crash_count<=15) { watchdog.reset(); }
    else { 
    reboot_state = 1; 
    EEPROM.put(0, reboot_state);
    EEPROM.put(120, millis()); 
    }
  }

}


void getdata() { 


 while (Serial7.available()) { gps.encode(Serial7.read()); }


  if ((millis()-baroA)>=10) { 
    baroA = millis();
    unsigned waitd = millis(); 
    Z = al.reading(bmp.readAltitude(baro_set)*100);
    if (((millis() - waitd) > 100)) {bmp.begin(0X11)} 
    Z = (Z/100);
    baro_count = (baro_count + 1);;
     
    if (baro_count >= 10) { 
      baro_count = 0; 
      new_baro = true; 
      dt = baroA-baroB;
      baroB = millis(); 
    } 
  }

}


void datacmpt() {

  
  if (((gps.location.age()) < 999) and (atof(fix_type.value()) == 3)) { gps_ok = true; }
  else { gps_ok = false; }

  if (gps.course.isUpdated()) {  
    new_cog = true;                                                 
    if (cog_valid(cog_count) == true) {
      cog_ok = true;                                                    
      setPoint_Home = TinyGPSPlus::courseTo(gps.location.lat(),gps.location.lng(),lat_B,lon_B);  
      errHome = getangle(gps.course.deg(), setPoint_Home);                                    
    }
    else { cog_ok = false; last_errHome = errHome; }                                                                 
    prev_cog = gps.course.deg();                                                        
  }

   
  if ((gps_ok == true) and (cog_ok == true)) { 
   
      if (new_cog == true) {
        
        raterror = getangle((last_errHome+180),(errHome+180))*gps_frequency ; raterror = rs.reading(raterror); 
        ratecog  = getangle(prev_cog_b,gps.course.deg())*gps_frequency;       ratecog  = rc.reading(ratecog);
        
        float PIDsum = ((NKp*errHome)+(NKd*raterror)); 
        
        cmd_mult = 1;  
        cmdHome  = PIDsum*cmd_mult ;
        
        if (vspeed<-5) { spiral = true; } 
        if (vspeed>-3) { spiral = false; } 
        if (spiral == true) { cmdHome = 0; }
    
        new_cog = false;
        last_errHome = errHome; 
        prev_cog_b = gps.course.deg(); 

        steer_auto = map(cmdHome, -180, +180, 1000, 2000); 
        steer_auto = constrain(steer_auto, servo_auto_min, servo_auto_max);  
     
    }    
  }
  
 else { steer_auto = 1500; }

 }
  


 if (new_baro == true) { 
  
  new_baro = false; 
  if ((initialised == false) and (reboot_state != 1)) { baro_set = (baro_set + ((0-Z)/100)); }
  if (millis()<=5000) { Z = 0; } 
  
  float da = (Z - prev_alt);
  
  if (abs(da) < 50) {
  float vps = (da/(dt/1000));
  vspeed = vs.reading(vps*100); 
  vspeed = (vspeed/100);
  } 
  prev_alt = Z; 
}

    baro_weight = (1+(abs(vspeed)/10));
    float hdo = gps.hdop.value(); 
    float gpsw = ((50/hdo)+(gps.altitude.meters()/10000)); 
    gps_weight = (gpsw*((abs(Z-gps.altitude.meters())/10)));
    
    merged_alt = ((Z*baro_weight)+(gps.altitude.meters()*gps_weight))/(baro_weight+gps_weight); 


  if ((millis()-tstab) >= 1000) { 
    tstab = millis(); 
    int update_count(int a){
      vcount = 0;
        if (abs(a < 1)) {vcount = (vcount + 1); }
      return vcount
     }
    vspeed_count = update_count(5*vspeed)
    gps_count = update_count(prev_gps-gps.altitude.meters())
  
    boolean stab(int b) {
     if (b >= 10) { is_stab = true; } 
      else if(millis()<(time_out*1000)) { is_stab = false; } 
      else { gps_stab = true; }
     return is_stab
    gps_stab = stab(gps_count)
    baro_stab = stab(vspeed_count)
    prev_gps = gps.altitude.meters();  

  }   


  gps_times = {[gps.date.year(), 2, 0, _year],[gps.date.month(), 1, 0, _month],[gps.date.day(), 1, 0, _day],
  [gps.time.hour(), 1, 0, _hour],gps.time.minute(), 1, 0, _minute],[gps.time.second(), 1, 0, _seconds]}
  for x in gps_times {
    dtostrf(x[0],x[1],x[2],x[3]);
  }
 
  snprintf(date_time, 100, "%s:%s:%s,%s:%s:%s", date_year, date_month, date_day, time_hour, time_minute, time_seconde);

  if (flight_rebooted == false) { time_number = ((gps.date.day()*1000000) + (gps.time.hour()*10000) + (gps.time.minute()*100) + gps.time.second()); } 
  gps_values = [[gps.location.lat(), 10, 10, lat_A_text],[gps.location.lng(), 10, 10, lon_A_text],[gps.altitude.meters(), 1, 1, alt_gps_text],
  [gps.course.deg(), 1, 0, cog_text],[gps.speed.mps(), 1, 1, speed_text],[gps.satellites.value(), 1, 0, sat_text],[(atof(fix_type.value()), 1, 0, fix_type_text)],
  [dtostrf(gps.hdop.value(), 1, 0, hdop_text)]]
  for x in gps_values {
    dtostrf(x[0],x[1],x[2],x[3]);
  }
  }
 
  
  if (gps.location.age()>10000) { dtostrf(9999, 1, 0, pos_age_text); } 
  else                         { dtostrf(gps.location.age(), 1, 0, pos_age_text); } 

  snprintf(gps_text, 120, "%s,%s,%s,%s,%s,%s,%s,%s,%s,%s", date_time, lat_A_text, lon_A_text, alt_gps_text, cog_text, speed_text, sat_text, hdop_text, pos_age_text, fix_type_text);

  dtostrf(Z, 1, 3, Z_text);
  dtostrf(vspeed, 1, 2, vspeed_text);
  
  snprintf(baro_text, 120, "%s,%s", Z_text, vspeed_text);  
  
  dtostrf(merged_alt, 2, 3, merged_alt_text);  
  dtostrf(gps_weight, 2, 2, gps_weight_text);
  dtostrf(baro_weight, 2, 3, baro_weight_text);
  
  dtostrf(setPoint_Home, 2, 2, setPoint_Home_text);
  dtostrf(errHome, 1, 2, errHome_text);
  dtostrf(raterror, 1, 0, raterror_text); 
  dtostrf(cmd_mult, 1, 3, cmd_mult_text); 
  
  dtostrf(lat_B, 1, 5, lat_B_text);
  dtostrf(lon_B, 1, 5, lon_B_text);

  dtostrf(next_cog, 1, 0, next_cog_text); 
      
  snprintf(nav_text, 140, "%s,%s,%s,%s,%s,%s,%s,%s,%s,%s", merged_alt_text, baro_weight_text, gps_weight_text, setPoint_Home_text, errHome_text, raterror_text, next_cog_text, cmd_mult_text, lat_B_text, lon_B_text);  


  dtostrf(servoL, 2, 0, left_text);
  dtostrf(servoR, 2, 0, right_text);
  dtostrf(servo_deploy, 2, 0, deploy_text);
  snprintf(servo_text, 40, "%s,%s,%s", left_text, right_text, deploy_text); 

  unsigned long long actual_time = (millis()+reboot_time); 
  dtostrf(actual_time, 1, 0, time_text);
  dtostrf(flight_mode, 1, 0, flight_mode_text);
  dtostrf(gps_ok, 1, 0, gps_ok_text);
  dtostrf(cog_ok, 1, 0, cog_ok_text);
  dtostrf(gps_stab, 1, 0, gps_stab_text);
  dtostrf(baro_stab, 1, 0, baro_stab_text);
  dtostrf(deployed, 1, 0, deployed_text);
  dtostrf(wing_opened, 1, 0, wing_opened_text);
  dtostrf(loop_time, 1, 0, looptime_text);
  dtostrf(packet_count, 1, 0, packet_count_text);
  dtostrf(initialised, 1, 0, initialised_text);
  
  snprintf(status_text, 100, "%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s", time_text, packet_count_text, flight_mode_text, gps_ok_text, cog_ok_text,gps_stab_text, baro_stab_text, deployed_text, wing_opened_text, initialised_text, looptime_text);  

  snprintf(mainSD, 340, "%s,%s,%s,%s,%s,%s", status_text, gps_text, baro_text, nav_text, rc_text, servo_text);

  switch(flight_mode) { 
      
    case 0: 
    delaySD = 200;
    break;

    case 1: 
    case 2: 
    case 3: 
    case 4: 
    case 5:
    case 6: 
    break;
      
  }
    

if (record_home == false) { 

  if (initialised == true) {

    if ((millis()-sd)>=delaySD) { 
      sd = millis(); 
    
      if (!SD.begin(chipSelect)) { sd_ok = false; }
      else { 
        sd_ok = true; 
        dataFile = SD.open(namebuff, FILE_WRITE);
      
        if (dataFile) { dataFile.println(mainSD); dataFile.close(); }
        else { sd_ok = false; }
    }
   }
  }
 }
 
}

void flight_state() {

  if (flight_mode != prev_mode) { 

    packet_count = (packet_count +1); 

    
    if (!SD.begin(chipSelect)) {}
    else { 
      dataFile = SD.open(namebuff, FILE_WRITE);
      if (dataFile) { dataFile.println(mainSD); dataFile.close(); }
    } 
   prev_mode = flight_mode;  
 }
  
  switch(flight_mode) { 
    
    case 0: 
      flight_init(); 
    break;

    case 1: 
      flight_ready(); 
    break;

    case 2: 
      flight_ascent(); 
    break;

    case 3: 
      flight_descent(); 
    break;

    case 4: 
      flight_gliding(); 
    break;

    case 5: 
      autopilot(); 
    break;
    
    case 6: 
      landed(); 
    break;
  }
}


void flight_init() { 

 if (reboot_state !=1) { 
  
  if (((gps.satellites.value() >= 6) and (gps_ok == true) and (gps_stab == true) and (millis()>5000)) or (no_initialize == false)) {

    lat_B = gps.location.lat();
    lon_B = gps.location.lng();

    initialised = true; 

    EEPROM.put(10, dep_altitude);
    EEPROM.put(30, lat_B);
    EEPROM.put(50, lon_B);

    while (abs(Z-gps.altitude.meters())>0.01) {
      if ((micros()-baro_blk)>10) { 
        baro_blk = millis();
        Z = (bmp.readAltitude(baro_set));
        baro_set = (baro_set + ((gps.altitude.meters()-Z)/8));
        prev_alt = Z; 
        watchdog.reset();
      }
    }

    EEPROM.put(70, baro_set);

    vs.reset(); 
    al.reset(); 
  
    dep_altitude = (dep_altitude+gps.altitude.meters());
  
    if (record_home == false) { newfile(); }   

    if (drop == true) { flight_mode = 1;}

    time_init = millis(); 
         
  }
 }

 else { 
 
  if ((gps.satellites.value() >= 6) and (gps_ok == true) and (millis()>5000)) {
   

    initialised = true; 

    vs.reset(); 
    al.reset(); 

      
    if (drop == true) { flight_mode = 1;}
    
    time_init = millis();

    dtostrf(time_number, 1, 0, sdnamebuff); 
    sprintf(namebuff, "%s.txt", sdnamebuff);

    reboot_state = 0; 
    EEPROM.put(0, 0); 
      
  }
 }
  
  if (millis()-sat_buzz>5000) { 
    sat_buzz = millis(); 

  } 
   
}


void flight_ready() { 

 if (millis()-time_init>=1000) { 
   
  if (vspeed>vzmax)    { flight_mode = 2}
  if (vspeed<vz_max)  { flight_mode = 3} 
  if ((atof(fix_type.value()) < 2) and (no_initialize == true))  { flight_mode = 0;}
 }
} 


void flight_ascent() { if (vspeed<0.5) {flight_mode = 1}  }


void flight_descent() { 
  
  if (vspeed>-0.5) {flight_mode = 1} 
  if (merged_alt < dep_altitude) { flight_mode = 4;}
 }   


void flight_gliding() {

  if (((millis()-time_init) >= gliding_timer) or (vspeed > (3))) { 
  wing_opened = true; 
  last_errHome = errHome; 
  flight_mode = 5
}


void autopilot() { 
  
  
  if (vspeed < -6) { spiral = true; } 
  if (vspeed > -5) { spiral = false; } 



void landed() { if ((baro_stab == false) or (gps_stab == false)) {flight_mode = 1} }


void applycmd()  { 


  switch(flight_mode) { 
    
    case 0: 
    case 1: 
    case 5: 
    
      if (autopilot_mode == 0) { 
        servoL = steer_auto; 
        servoR = 3000-steer_auto; 
      }
      
      else {
        
        if (steer_auto < 1450) {
         servo_left = map(steer_auto, 1000, 1500, 2000, servoLmin);
         servo_right = servoRmax;
        }
           
        else if (steer_auto > 1550) { 
         servo_right = map(steer_auto, 2000, 1500, 2000, servoRmin);
         servo_left = servoLmax; 
        }
        
        else if ((steer_auto>1450) and (steer_auto<1550)) { 
          servo_left = servoLmax; 
          servo_right = servoRmax; 
        }
        
      } 
    break;
  
    case 2: 
    case 3: 
    case 4: 
      servoL = 1500; 
      servoR = 1500; 
    break; 
    
  }
// Deployment Servo 

  switch(flight_mode) { 
    
  
    case 0: 
    case 1:
    case 2:
    case 3:
    case 4:
    case 5: 
    case 6: 
     if (deployed == true) { servo_deploy = 1500; }
     else {
      servo_deploy = 2000;

      }
   break; 

}


void updatecmd(float a) { 
  
  if ((millis()-tpwm)>=(1000/a)) { 
    
    tpwm = millis(); 
    left.write(map(servoL,1000,2000,5,175));
    right.write(map(servoR,1000,2000,5,175)); 

    
  }
 } 


boolean cog_valid(int a) { 
  if (abs(gps.course.deg()-prev_cog)<0.1) { valid_count++; }
  else { valid_count = 0; } 
  if (valid_count >= a) { return false; }
  else { return true; } 
}

float getangle(float a, float b) { 
  float angle = 0; 
  if (abs(a-b) < 180) { angle = (b-a);}
  else { 
    if ((a-b) < 0) { angle = (-360) +(b-a);}
    else { angle = (360) + (b-a);}
  }
  return angle;  
}


void gpset(int a, int b, int c, int d, int e){
  
if (a == 9600) {
    gps_port.begin(9600); 
    delay(100); 
    byte packet1[] = {0xB5, 0x62, 0x06, 0x00, 0x14, 0x00, 0x01, 0x00, 0x00, 0x00, 0xC0, 0x08, 0x00, 0x00, 0x80, 0x25, 0x00, 0x00, 0x07, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x92, 0xB5};
    sendPacket(packet1, sizeof(packet1));
  }
    
if (a == 57600) { 
    gps_port.begin(9600); 
    delay(100);
    byte packet2[] = {0xB5, 0x62, 0x06, 0x00, 0x14, 0x00, 0x01, 0x00, 0x00, 0x00, 0xC0, 0x08, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x07, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCE, 0xC9};
    sendPacket(packet2, sizeof(packet2));
    gps_port.end(); 
    gps_port.begin(57600); 
    delay(100);
  }

if (a == 115200) { 
    gps_port.begin(9600); 
    delay(100);
    byte packet3[] = {0xB5, 0x62, 0x06, 0x00, 0x14, 0x00, 0x01, 0x00, 0x00, 0x00, 0xC0, 0x08, 0x00, 0x00, 0x00, 0xC2, 0x01, 0x00, 0x07, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB0, 0x7E};
    sendPacket(packet3, sizeof(packet3)); 
    gps_port.end(); 
    gps_port.begin(115200);
    delay(100);
  }

if (b == 1) { 
    byte packet4[] = {0xB5, 0x62, 0x06, 0x08, 0x06, 0x00, 0xE8, 0x03, 0x01, 0x00, 0x01, 0x00, 0x01, 0x39};
    sendPacket(packet4, sizeof(packet4));
  }

if (b == 5) { 
    byte packet5[] = {0xB5, 0x62, 0x06, 0x08, 0x06, 0x00, 0xC8, 0x00, 0x01, 0x00, 0x01, 0x00, 0xDE, 0x6A};
    sendPacket(packet5, sizeof(packet5));
  }
    
if (b == 10) { 
    byte packet6[] = {0xB5, 0x62, 0x06, 0x08, 0x06, 0x00, 0x64, 0x00, 0x01, 0x00, 0x01, 0x00, 0x7A, 0x12};
    sendPacket(packet6, sizeof(packet6));
  }

if (c == 0) { 
    byte packet7[] = {0xB5, 0x62, 0x06, 0x24, 0x24, 0x00, 0xFF, 0xFF, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x10, 0x27, 0x00, 0x00, 0x05, 0x00, 0xFA, 0x00, 0xFA, 0x00, 0x64, 0x00, 0x5E, 0x01, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x3C};
    sendPacket(packet7, sizeof(packet7));
  }
    
if (c == 1) {
    byte packet8[] = {0xB5, 0x62, 0x06, 0x24, 0x24, 0x00, 0xFF, 0xFF, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x10, 0x27, 0x00, 0x00, 0x05, 0x00, 0xFA, 0x00, 0xFA, 0x00, 0x64, 0x00, 0x5E, 0x01, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x08};
    sendPacket(packet8, sizeof(packet8)); 
  }

if (c == 2) {
    byte packet8[] = {0xB5, 0x62, 0x06, 0x24, 0x24, 0x00, 0xFF, 0xFF, 0x07, 0x03, 0x00, 0x00, 0x00, 0x00, 0x10, 0x27, 0x00, 0x00, 0x05, 0x00, 0xFA, 0x00, 0xFA, 0x00, 0x64, 0x00, 0x5E, 0x01, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x2A};
    sendPacket(packet8, sizeof(packet8)); 
  }

if (c == 4) {
    byte packet8[] = {0xB5, 0x62, 0x06, 0x24, 0x24, 0x00, 0xFF, 0xFF, 0x08, 0x03, 0x00, 0x00, 0x00, 0x00, 0x10, 0x27, 0x00, 0x00, 0x05, 0x00, 0xFA, 0x00, 0xFA, 0x00, 0x64, 0x00, 0x5E, 0x01, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86, 0x4C};
    sendPacket(packet8, sizeof(packet8)); 
  }

if (d == 1) { 
    byte packet9[] = {0xB5, 0x62, 0x06, 0x01, 0x08, 0x00, 0xF0, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x03, 0x35};
    byte packet10[] = {0xB5, 0x62, 0x06, 0x01, 0x08, 0x00, 0xF0, 0x03, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x05, 0x43};
    sendPacket(packet9, sizeof(packet9));
    sendPacket(packet10, sizeof(packet10));
  }

if (e == 1) {
    byte packet11[] = {0xB5, 0x62, 0x06, 0x1E, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x32, 0x00, 0x00, 0x99, 0x4C, 0x00, 0x00, 0x5B, 0x10};
    sendPacket(packet11, sizeof(packet11));
  }

  gps_port.addMemoryForRead(serial2bufferRead, sizeof(serial2bufferRead));
   
}

void sendPacket(byte *packet, byte len){
    for (byte i = 0; i < len; i++) { gps_port.write(packet[i]); }
}

void newfile() { 
  dtostrf(time_number, 1, 0, sdnamebuff); 
    sprintf(namebuff, "%s.txt", sdnamebuff);
    
    if (!SD.begin(chipSelect)) {}
    else { 
      SdFile::dateTimeCallback(dateTime);
      dataFile = SD.open(namebuff, FILE_WRITE);
      delay(10); 
      if (dataFile) {  
        dataFile.println("time (ms), Packet_Count (text), Mode (text), GPS_Ok (text), COG_Ok (text), FailSafe (text), GPS_Stab (text), Baro_Stab (text), Deployed (text), Wing_Opened (text), Initialised (tex), Looptime (µS), GPS-date, GPS-time, lat (deg), lon (deg), alt (m), CoG (deg), Speed (m/s), Sat_in_use (text), HDOP (text), Position_Age (text), Fix_type (text), Baro_Alt (m), Vertical_Speed (m/s), Altitude (m), Baro_Weight (text), GPS_Weight (text), SetPoint_Home (deg), Err_Home (deg), Rate_Error (deg), Next_Cog (deg), Cmd_mult (text), LatB (deg), LonB (deg), Ch 0 (µs), Ch 1 (µs), Ch 2 (µs), Ch 3 (µs), Ch 4 (µs), Ch 5 (µs), Ch 6 (µs), PWM_L (µs), PWM_R (µs), PWM_D (µs)");
        dataFile.close();
        EEPROM.put(90, time_number);
    }
  }
}

