#include <TinyGPS++.h>
#include <movingAvg.h>
#include <Watchdog.h>
#include <Wire.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_LSM303_U.h>
#include <Adafruit_BMP085_U.h>
#include <Adafruit_L3GD20_U.h>
#include <Adafruit_10DOF.h>
#include <PWMServo.h>
#include <PID_v1.h>
#include <SoftwareSerial.h>


//Moving Averages
movingAvg baro_alt_avg(50); 
movingAvg baro_vs_avg(1);
movingAvg baro_vavg(5);
movingAvg gps_vs_avg(1); 
movingAvg gps_vavg(10); 
movingAvg pressure_avg(1); 
movingAvg press_percent_avg(50); 


//GPS
TinyGPSPlus gps;
TinyGPSCustom fix_type(gps, "GNGSA", 2);
static const int GRXPin = 2, GTXPin = 3;
static const uint32_t GPSBaud = 9600;
SoftwareSerial Gss(GRXPin, GTXPin);
float prev_alt_gps = 0; 
float gps_vspeed   = 0; 
unsigned long gpsB = 0;
float prev_cog     = 0; 
bool new_gps = false;
bool new_cog = false;
bool gps_ok = false; 
bool cog_ok = false; 


//Altimiter

Watchdog watchdog; 

Adafruit_10DOF                dof   = Adafruit_10DOF();
Adafruit_LSM303_Accel_Unified accel = Adafruit_LSM303_Accel_Unified(30301);
Adafruit_LSM303_Mag_Unified   mag   = Adafruit_LSM303_Mag_Unified(30302);
Adafruit_BMP085_Unified       bmp   = Adafruit_BMP085_Unified(18001);

double baro_set  = 1000.0; 
float alt_baro      = 0;
float pressure_baro = 0; 
float prev_alt_baro = 0; 
float baro_vspeed   = 0; 
float baro_count    = 0; 
float loop_number = 0;
float loop_speed = 0;
bool new_baro       = false;
bool stable_descent = false; 

unsigned long alt_timer_a     = 0; 
unsigned long alt_timer_b     = 0; 
unsigned long baro_blk  = 0;
unsigned long baro_clb  = 0;
unsigned long loop_time = 0;



//Servos
PWMServo steer;
PWMServo left; 
PWMServo right; 

int servo_left  = 0;
int servo_right = 0;
int servo_aux   = 0; 
unsigned long pwm_timer = 0; 

struct servo_cmd {
  float left = 1500;
  float right = 1500; 
  
};
 
 


//Flight State
int flight_mode   = 0; 
int dep_altitude  = 0; 
int sep_altitude = 0; 
int prev_flight_mode = 0; 
bool initialised  = false;
bool flight_started = false;
bool deployed     = false; 
bool wing_opened  = false; 
bool spiral = false;
bool separation = false;
unsigned long spiral_time = 0; 
unsigned long init_time = 0; 

//Position

float merged_alt = 0; 
float merged_vspeed = 0; 

float baro_alt_weight = 1;
float gps_alt_weight = 1; 
float baro_vspeed_weight = 1;
float gps_vspeed_weight = 1; 

float ground_altitude = 0;
unsigned long tstab = 0; 

float gps_stab_factor = 0; 
float baro_stab_factor = 0; 

bool new_baro_fusion = false;
bool new_gps_fusion = false; 

double pressure_percentage;


//Main
servo_cmd steering; 

float setPoint_waypoint = 0; 
float error_waypoint    = 0; 
float cmd_to_waypoint   = 0;

//Navigation
struct gps_location { 
  double latitude = 0; 
  double longitude = 0; 
  double radius = 0; 
};

gps_location waypoint[17]; 
gps_location current_waypoint; 

int waypoint_number = 0; 
int last_waypoint_number = 0; 

//Moving

int SERVO_MAX_M_W = 0; 
int SERVO_MAX_C_W = 0; 

int SERVO_MAX_M = 0; 
int SERVO_MAX_C = 0; 

double Setpoint, Input, Output;
PID myPID(&Input, &Output, &Setpoint,NKP, NKI, NKD, DIRECT);

unsigned long time_gain = 0; 


//GPS 
void calc_vertical_speed_gps(float da, int dt) {
  gps_vspeed = (da/(dt/1000.0));
  gps_vspeed = gps_vs_avg.reading(gps_vspeed/100); 
  gps_vspeed = (gps_vspeed/100);
  gps_vspeed = constrain(gps_vspeed, -50, 10); 
  if (DEBUG) { Serial.println("vert speed calc"); 
  Serial.println(gps_vspeed);}
}

void get_gps() {  
  
  while (Gss.available()) { 
    gps.encode(Gss.read()); 
    if (DEBUG) { Serial.println("GPS avail"); }
  }
  
  if (((gps.location.age()) < ((1000/GPS_FREQ)*2)) and (atof(fix_type.value()) == 3)) { 
    gps_ok = true; 
    if (DEBUG) { Serial.println("GPS ok"); }
  }
  else { gps_ok = false; }
  
  if (gps.course.isUpdated()) {
    if (abs(prev_cog-gps.course.deg())>0.1 or gps.speed.mps()>3) {
      cog_ok = true; 
      new_cog = true;
      prev_cog = gps.course.deg(); 
    }
    else { cog_ok = false; }
  }

  if (gps.altitude.isUpdated()) {
    calc_vertical_speed_gps(gps.altitude.meters()-prev_alt_gps, (millis()-gps.altitude.age())-gpsB);
    gpsB = millis(); 
    prev_alt_gps = gps.altitude.meters(); 
    new_gps = true; 
  }
}


 
void sendPacket(byte *packet, byte len){
    for (byte i = 0; i < len; i++) { Gss.write(packet[i]); }
}

void gps_setup(int a, int b, int c, int d, int e){

  gps_vs_avg.begin();
  Gss.begin(GPSBaud);
  if(DEBUG){
    Serial.println("gps set up");
  }
}





void baroset(float alt_set, int factor) { 
  do {
      if ((micros()-baro_blk)>=10) {
        sensors_event_t event;
        bmp.getEvent(&event);
        if (event.pressure){
          float temperature;
          bmp.getTemperature(&temperature);
        float seaLevelPressure = SENSORS_PRESSURE_SEALEVELHPA;
        baro_blk = millis();
        alt_baro = bmp.pressureToAltitude(baro_set,event.pressure,temperature);
        baro_set = (baro_set + ((alt_set-alt_baro)/(8*factor)));
        prev_alt_baro = alt_baro; 
        watchdog.reset();
        if(DEBUG){
          Serial.println("baroset");
          Serial.println(baro_set);
        }
        }
      }
     } while (abs(alt_baro-alt_set)>0.01); 
}


void baro_adjust(float alt_set, int factor) {
  if ((millis()-baro_clb)>1000) {
    baro_clb = millis();
    sensors_event_t event;
    bmp.getEvent(&event);
    if (event.pressure){
      float temperature;
      bmp.getTemperature(&temperature);
      float seaLevelPressure = SENSORS_PRESSURE_SEALEVELHPA;
      baro_blk = millis();
      alt_baro = bmp.pressureToAltitude(baro_set,event.pressure,temperature);
      baro_set = (baro_set + ((alt_set-alt_baro)/(8*factor)));
      if(DEBUG){
          Serial.println("baroadjusted");
          Serial.println(baro_set);
        }
  }
}
}


void barometer_setup() {
  Serial.begin(115200);

  
  /* Initialise the sensors */
  Serial.println(F("Ainit2")); Serial.println("");
  baro_vs_avg.begin(); 
  baro_alt_avg.begin();
  pressure_avg.begin(); 
  if (bmp.begin()) {
    baroset(0, 1);  
    if (DEBUG) { Serial.println("Baro was set correctly"); } 
  }
  else {
    if (DEBUG) { Serial.println("Failure"); }
    delay(1500); 
  }
}
  

void calc_vertical_speed_baro(float da, int dt) {  
  baro_vspeed  = (da/(dt/1000.0));
  baro_vspeed = baro_vs_avg.reading(baro_vspeed*100); 
  baro_vspeed = (baro_vspeed/100);
  baro_vspeed = constrain(baro_vspeed, -50, 10);
  if(DEBUG){
          Serial.println("barovspeed");
          Serial.println(baro_vspeed);
        }
}

void get_baro(int mode) {
  if ((millis()-alt_timer_a)>=10 and mode == 0) {
     
    if (DEBUG) { Serial.println("Got a Baro message"); } 
  
    alt_timer_a = millis();
    unsigned waitd = millis(); 
    
    sensors_event_t event;
    bmp.getEvent(&event);
    if (event.pressure){
      float temperature;
      bmp.getTemperature(&temperature);
      float seaLevelPressure = SENSORS_PRESSURE_SEALEVELHPA;
      baro_blk = millis();
      alt_baro = bmp.pressureToAltitude(baro_set,event.pressure,temperature);
    pressure_baro = event.pressure;
    if (DEBUG) { Serial.println(alt_baro); 
    Serial.println(pressure_baro);
    }
    }
        
    alt_baro = (baro_alt_avg.reading(alt_baro*100.0)/100.0);
    pressure_baro = (pressure_avg.reading(pressure_baro*100.0)/100.0);

    if (DEBUG) { Serial.println(alt_baro); 
    Serial.println(pressure_baro);
    }
    

    if (((millis() - waitd) >= 100)) { 
      barometer_setup(); 
    } 
    baro_count = (baro_count + 1);;
    if(DEBUG){
          Serial.println("barocount");
          Serial.println(baro_count);
        }
    if (baro_count >= 50) { 
      baro_count = 0; 
      calc_vertical_speed_baro(alt_baro-prev_alt_baro, alt_timer_a-alt_timer_b); 
      alt_timer_b = millis(); 
      prev_alt_baro = alt_baro; 
      new_baro = true;
      if(DEBUG){
          Serial.println("newbaro");
          Serial.println(new_baro);
        }
    } 
  }

  else if (mode == 1) {
    alt_timer_a = millis();
    unsigned waitd = millis(); 
    
    sensors_event_t event;
    bmp.getEvent(&event);
    if (event.pressure){
      float temperature;
      bmp.getTemperature(&temperature);
      float seaLevelPressure = SENSORS_PRESSURE_SEALEVELHPA;
      baro_blk = millis();
      alt_baro = bmp.pressureToAltitude(baro_set,event.pressure,temperature);
      pressure_baro = event.pressure;
    }
        
    alt_baro = (baro_alt_avg.reading(alt_baro*100.0)/100.0);
    pressure_baro = (pressure_avg.reading(pressure_baro*100.0)/100.0);
    if(DEBUG){
          Serial.println("mode1baro");
          Serial.println(alt_baro);
          Serial.println(pressure_baro);
        }
        

    new_baro = true;
  }
} 


//Servos
void servo_setup() {
  left.attach(9, 1000, 2000);  
  right.attach(10, 1000, 2000); 
  if(DEBUG){
          Serial.println("servo_setup");
        }
}
servo_cmd calc_servo(int autopilot, int flight_mode, bool deployed, bool cog_ok, bool spiral, bool separation) {


  servo_cmd steering_calc ;
  if(DEBUG2){
          Serial.println("calc_servo: flight mode, autopilot, control mode");
          Serial.println(flight_mode);
          Serial.println(autopilot);
        }
        
  
  switch(flight_mode) {  
    case 0: 
    case 1: 
    case 6: 
    case 5: 
    if (cog_ok and !spiral) {
      steering_calc.right = autopilot; 
      steering_calc.left = 3000-autopilot; 
    }
    else {
      steering_calc.right = 1500; 
      steering_calc.left = 1500; 
    }
    break; 

    case 11: 
    steering_calc.right = 1500; 
    steering_calc.left = 1500; 
    break; 
    
  }


  // ---------- Stage 3 - Control mode ---------- // 
  switch (CONTROL_MODE) {
          
    case 0: // neutral is center 
    break; 

    case 1: // neutral is hands up 
    steering_calc.right = constrain(map(steering_calc.right, 1500, 2000, 1000, SERVO_MAX_M), 1000, SERVO_MAX_C);
    steering_calc.left = constrain(map(steering_calc.left, 1500, 2000, 1000, SERVO_MAX_M), 1000, SERVO_MAX_C);
    break; 
  }
  
  servo_left = steering_calc.left; 
  servo_right = steering_calc.right; 
 
  
  return steering_calc;  
}


void update_servo_cmd(servo_cmd steering_apply, unsigned int a) {
   
  if ((millis()-pwm_timer)>=(1000/a)) {  
    pwm_timer = millis(); 
    left.write(map(steering_apply.left, 1000, 2000, 0, 180));
    right.write(map(steering_apply.right, 1000, 2000, 0, 180)); 
   // if(DEBUG){
         // Serial.println("servo command updated");
         // Serial.println(steering_apply.left);
         // Serial.println(steering_apply.right);
       // }
    
    
  }
 
}

//Flight State
//------------------- 0 -------------------//

void flight_init() { 
  if(DEBUG2){
          Serial.println("flight init: satellites, hdop, millis");
          Serial.println(gps.satellites.value());
          Serial.println(gps.hdop.value());
          Serial.println(millis());
        }
  
  if ((gps.satellites.value()>=6 and gps_ok and gps.hdop.value()<150 and millis()>5000) or NO_INIT) {

      current_waypoint.latitude = gps.location.lat();
      current_waypoint.longitude = gps.location.lng();
      current_waypoint.radius = HOME_WAYPOINT_THRESHOLD; 
       if(DEBUG){
          Serial.println("gpsok: current waypoint lat, lon, radius");
          Serial.println(current_waypoint.latitude);
          Serial.println(current_waypoint.longitude);
          Serial.println(current_waypoint.radius);
        }

   
    baro_vs_avg.reset(); 
    baro_alt_avg.reset(); 
    gps_vs_avg.reset();
    
    baroset(gps.altitude.meters(), 1); 
    get_baro(1);
    merged_alt = gps.altitude.meters(); 

    ground_altitude = gps.altitude.meters();
    ground_altitude = constrain(ground_altitude, 0, 2000); 
    
    dep_altitude = (DEP_ALT+ground_altitude);
    sep_altitude = (SEP_ALT+ground_altitude); 
 
    flight_mode = 1;

    init_time = millis(); 
    initialised = true;      
    if(DEBUG2){
          Serial.println("alt: merged alt, ground alt, dep alt, sep alt");
          Serial.println(merged_alt);
          Serial.println(ground_altitude);
          Serial.println(dep_altitude);
          Serial.println(sep_altitude);
        }

 }

  
}

//------------------- 1 -------------------//

void ready_steady() { 
  if(DEBUG){
          Serial.println("flight mode: ready");
        }

 if (millis()-init_time>=3000) { 

  if (is_ascent(VUP, 0))  {
    flight_mode = 2; 
    if(DEBUG){
          Serial.println("ascent: new flight mode" );
          Serial.println(flight_mode);
        
        }
     
  }
   
  if (is_descent(v_down(VDOWN), 1)) {  
    flight_mode = 3; 
    init_time = millis();
    if(DEBUG){
       Serial.println("descent: new flight mode" );
       Serial.println(flight_mode);
       Serial.println(init_time);
        }
  } 
  
  if ((atof(fix_type.value()) < 2) and (NO_INIT == false) and (flight_started == false))  { 
    flight_mode = 0; 
    if(DEBUG){
       Serial.println("fix_type<2, No_init false: flight started = false: new flight mode" );
       Serial.println(flight_mode);
       Serial.println(init_time);
        }
  }

  if (I_WANT_TO_FLY) {
    flight_mode = 5; 
    if(DEBUG){
       Serial.println("I wan to fly" );
       Serial.println(flight_mode);
        }
  }   
 }
} 

//------------------- 2 -------------------//

void flight_ascent() { 
  if(DEBUG){
       Serial.println("flight ascent " );
        }
  if (is_descent(0, 0)) {
    flight_mode = 1;
      if(DEBUG){
       Serial.println("back to ready steady" );
        }

  }  
  if ((gps.altitude.meters()-ground_altitude)>10) {
    flight_started = true; 
    if(DEBUG){
       Serial.println("flight started: (gps_alt-groundalt>10)" );
        }
  }
  if (gps.altitude.meters()>sep_altitude and gps_ok) {
    separation = true;
    if(DEBUG){
       Serial.println("seperation true" );
        }
  }
}

//------------------- 3 -------------------//

void flight_descent() { 
  if(DEBUG){
       Serial.println("flight descent" );
        }
  if (is_ascent(0, 0)) {
    flight_mode = 1; 
    Serial.println("back to ready steady" );
  } 

  if ((DEP_MODE and (millis()-init_time>DESCENT_TIMER)) or ((!DEP_MODE and merged_alt < dep_altitude))) { 
    flight_mode = 4;
    deployed = true; 
    init_time = millis(); 
   // if(DEBUG){
   //    Serial.println("alt<dep_alt: flight mode, init time" );
     //  Serial.println(flight_mode);
     //  Serial.println(init_time);
        //}
  }  
 }   

//------------------- 4 -------------------//

void flight_gliding() {
  if(DEBUG){
       Serial.println("flight gliding: Opening timer, millis-init time" );
       Serial.println(OPENING_TIMER);
       Serial.println(millis()-init_time);
        }

  if ((millis()-init_time) >= OPENING_TIMER) {
    wing_opened = true; 
    flight_mode = 5; 
    myPID.SetMode(AUTOMATIC);
   // if(DEBUG){
   //    Serial.println("gliding: new flight mode, wing opened" );
  //     Serial.println(flight_mode);
    //   Serial.println(wing_opened);
     //   }
}
}

//------------------- 5 -------------------//

void flight_gliding_auto() { 
  if(DEBUG){
       Serial.println("flight gliding auto" );

        }

  if (!gps_ok) {
    flight_mode = 11;  
    myPID.SetMode(MANUAL);
   // if(DEBUG){
    //   Serial.println("gps not ok: new flight mode" );
    //   Serial.println(flight_mode);
      //  }
  }

  if (is_descent(v_down(-5), 1)) {
    spiral = true; 
    spiral_time = millis();
    if(DEBUG){
       Serial.println("spiraling too fast: spiral true" );
       Serial.println(spiral_time);
        }
  }

  if (millis()-spiral_time>SPIRAL_RECOVER) {
    spiral = false;
    if(DEBUG){
       Serial.println("Spiral recovered" );
        }
  }
  
  
  navigation(); 
}


//------------------- 7 -------------------//

void landed() {  
  if(DEBUG){
       Serial.println("landed" );
        }
}


//------------------- 11 -------------------//

void flight_gliding_no_gps() {
  if(DEBUG){
       Serial.println("gliding no gps" );

        }
  if (gps_ok) {
    flight_mode = 5; 
    myPID.SetMode(AUTOMATIC);
  }
}

//------------------- STATE MACHINE -------------------//

void calc_flight_state() {
  if(DEBUG){
       Serial.println("calc flight state: flight mode" );
       Serial.println(flight_mode);

        }

  if (flight_mode!=prev_flight_mode and prev_flight_mode !=0) {
      prev_flight_mode = flight_mode; 
  }
  
  switch(flight_mode) { 
    case 0: 
      flight_init(); 
    break;

    case 1: 
      ready_steady(); 
    break;

    case 2: 
      flight_ascent(); 
    break;

    case 3: 
      flight_descent();
    break;

    case 4: 
      flight_gliding(); 
    break;

    case 5: 
      flight_gliding_auto(); 
    break;


    case 7: 
      landed(); 
    break;

    case 11: 
      flight_gliding_no_gps(); 
    break; 
  }
}

//Pos
void position_setup() {
  if(DEBUG){
       Serial.println("position setup" );
        }
  gps_vavg.begin(); 
  baro_vavg.begin(); 
  press_percent_avg.begin();
}

void calc_fusion() {
  if(DEBUG){
       Serial.println("calc fusion" );
        }
  if (new_baro_fusion == true and new_gps_fusion == true) {
    new_baro_fusion = false;
    new_gps_fusion = false; 
     
    pressure_percentage = (press_percent_avg.reading((pressure_baro / (baro_set*100.0))*100.0)/100.0) ;
    pressure_percentage = constrain(pressure_percentage, 0.05, 1); 
    
    baro_alt_weight = pressure_percentage*pressure_percentage;
    baro_vspeed_weight = pressure_percentage*pressure_percentage;

    double h_dop = gps.hdop.value(); 
   
    
  
    if (gps_ok) { 
      gps_alt_weight = constrain((gps.altitude.meters()/3000), 0.1, 10);
      gps_vspeed_weight = constrain((gps.altitude.meters()/6000), 0.05, 10); 
    }
    else { 
      gps_alt_weight = 0; 
      gps_vspeed_weight = 0; 
    }
      
    merged_alt = ((alt_baro*baro_alt_weight)+(gps.altitude.meters()*gps_alt_weight))/(baro_alt_weight+gps_alt_weight); 
    merged_vspeed = ((baro_stab_factor*baro_vspeed_weight)+(gps_stab_factor*gps_vspeed_weight))/(baro_vspeed_weight+gps_vspeed_weight); 
    if(DEBUG){
       Serial.println("new baro fusion new gps fusion: pressure percentage, baro_alt_weight, baro_vspeed_weight, gps_alt_weight, gps_vspeed_weight, merged_alt, merged_vspeed " );
       Serial.println(pressure_percentage);
       Serial.println(baro_alt_weight);
       Serial.println(baro_vspeed_weight);
       Serial.println(gps_alt_weight);
       Serial.println(gps_vspeed_weight);
       Serial.println(merged_alt);
       Serial.println(merged_vspeed);
        }
    
  }
}

void calc_vertical_state() {
  if (new_baro) {
    new_baro = false; 
    new_baro_fusion = true;
    baro_stab_factor = (baro_vavg.reading(baro_vspeed*100.0))/100.0;
  }
  if (new_gps) {
    new_gps = false; 
    new_gps_fusion = true;
    gps_stab_factor = (gps_vavg.reading(gps_vspeed*100))/100.0; 
  }
}

bool is_ascent(int v_trigger, bool mode) {
  if (mode == 0) {
    if (baro_stab_factor>v_trigger) {
      return true;
    }
    else {
      return false;
    }
  }
  else {
    if (gps_stab_factor>v_trigger and baro_stab_factor>v_trigger) {
      return true;
    }
    else {
      return false;
    }
  } 
}

bool is_descent(int v_trigger, bool mode) {
  if (mode == 0) {
    if (baro_stab_factor<v_trigger) {
      return true;
    }
    else {
      return false;
    }
  }
  else {
    if (merged_vspeed<v_trigger) {
      return true;
    }
    else {
      return false;
    }
  }   
}

float pressure_sqrt_ratio() {
  double raw_ratio = sqrt((baro_set*100.0)/pressure_baro);
  return constrain(raw_ratio, 1, 5); 
}

float v_down(int vdown) {
  return pressure_sqrt_ratio()*vdown;
}

//Nav
float getangle(float a, float b) { 
  float angle = 0; 
  if (abs(a-b) < 180) { angle = (b-a);}
  else { 
    if ((a-b) < 0) { angle = (-360) +(b-a);}
    else { angle = (360) + (b-a);}
  }
  return angle;    
}

float calc_setpoint(gps_location waypoint) {                                                
  return TinyGPSPlus::courseTo(gps.location.lat(),gps.location.lng(),waypoint.latitude,waypoint.longitude);                                      
}

float calc_error(float cog, float setPoint) {
  return getangle(cog, setPoint); 
}

void navigation() {
  if(DEBUG){
       Serial.println("navigation" );

        }
   
  if (NAV_WAYPOINT == true) {
    if(DEBUG){
       Serial.println("waypoint nav" );

        }
    
    float distance_to = TinyGPSPlus::distanceBetween(gps.location.lat(),gps.location.lng(),current_waypoint.latitude,current_waypoint.longitude);
     
    if (distance_to < current_waypoint.radius) { 
      
      if (waypoint_number < 15) { 
        waypoint_number++;
      } 
      
      if ((waypoint[waypoint_number].latitude !=0) and (waypoint[waypoint_number].longitude !=0)) {
        current_waypoint = waypoint[waypoint_number]; 
      }  
    }   
  } 
}

void navigation_setup() {
  myPID.SetTunings(NKP, NKI, NKD);
  myPID.SetOutputLimits(-180, 180);
  myPID.SetMode(MANUAL);
  if (DEBUG) { Serial.println("PIDs set correctly"); } 
}

float calc_cmd(float err) {      
  Input = -err; 
  Setpoint = 0; 
  myPID.Compute();
  return map(Output, -180, 180, 1000, 2000); 
}

void calc_weight_gain() {
  if (AUTO_GAIN_WEIGHT) {
    int total_weight = SYSTEM_WEIGHT+PAYLOAD_WEIGHT;
    total_weight = constrain(total_weight, 500, 1500); 
    SERVO_MAX_M_W = map(total_weight, 500, 1500, 2000, 1500); 
    SERVO_MAX_C_W = map(total_weight, 500, 1500, 1750, 1350); 
  }
  else {
    SERVO_MAX_M_W = SERVO_MAX_M_DEF;
    SERVO_MAX_C_W = SERVO_MAX_C_DEF;
  }
}

void calc_pressure_gain(float pressure_ratio) {
  if (millis()-time_gain>1000) {
    time_gain = millis();  
    if (AUTO_GAIN_PRESSURE) {
      SERVO_MAX_M = constrain(map((SERVO_MAX_M_W-1000)/pressure_ratio, 0, 1000, 1000, 2000), 1250, 2000); 
      SERVO_MAX_C = constrain(map((SERVO_MAX_C_W-1000)/pressure_ratio, 0, 1000, 1000, 2000), 1250, 2000);
    }
    else {
      SERVO_MAX_M = SERVO_MAX_M_W;
      SERVO_MAX_C = SERVO_MAX_C_W; 
    }
  }
}

//Main

void setup() {

  Serial.begin(115200);


  if (DEBUG) { Serial.println("Ready to initialise all the hardware"); } 

 

  gps_setup(57600, GPS_FREQ, 2, 1, 0); // baud, Hz, mode, nmea, cog filter (0 = Off, 1 = On)

  servo_setup();
  position_setup();
  watchdog.reset();
  barometer_setup();  
  navigation_setup(); 
  calc_weight_gain();
}

void loop() {
  
  watchdog.reset();

  getdata();  // Getting data from all the sensors 
  datacalc(); // Using this data to do all what we have to do 
  loop_number++;     

  if ((millis()-loop_time)>=1000) {
    loop_time = millis(); 
    loop_speed = loop_number;
    loop_number = 0; 
  }

  if (DEBUG2) {
    delay(10); 
  }
  
}

void getdata() { 
 get_gps(); 
 get_baro(0); 
 
 
}

void datacalc() {

  calc_pressure_gain(pressure_sqrt_ratio()); 
  
  if (new_cog) {
    new_cog = false;
    if (DEBUG) { Serial.println("datacalc"); }  
    setPoint_waypoint = calc_setpoint(current_waypoint); 
    error_waypoint    = calc_error(gps.course.deg(), setPoint_waypoint);
    cmd_to_waypoint   = calc_cmd(error_waypoint);
  }

  steering = calc_servo(cmd_to_waypoint, flight_mode, deployed, cog_ok, spiral, separation);
  update_servo_cmd(steering, SERVO_RATE); 

  calc_flight_state(); 
   
  
  if (initialised) {
    calc_vertical_state();
    calc_fusion(); 
  }
  
 

}
